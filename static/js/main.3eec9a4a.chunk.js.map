{"version":3,"sources":["constants.js","VizBox/index.js","App.js","serviceWorker.js","index.js"],"names":["COLOR_SWATCH","VizBox","props","toggleBigCircleFill","fociData","f","focibigcirccolor","color","fociBigCirc","attr","d","toggleBigCircleLine","focibigcircleline","toggleSmallCircleFill","nodesData","n","nodecirclefill","nodeCirc","toggleSmallCircleLine","nodecircleline","state","data","categories","dict","jsondict","id","this","draw","nextProps","setState","vizboxname","toString","onClick","style","fontSize","type","min","max","margin","backgroundColor","minWidth","outline","undefined","length","d3","select","remove","height","width","ctx","document","createElement","getContext","clusterPadding","nodePadding","that","svg","append","call","on","foci","transform","node","myrs","mymaxfontsize","myminfontsize","producePowerScale","rs","maxFontSize","minFontSize","wordsWithFreqs","group","words","word","map","includes","push","sort","a","b","justFreqs","Set","myMaxFreq","lastFreq","freqWithFontSize","ff","powerScaleDict","myMaxFontSize","getElementById","value","text","parseInt","powerScaleDict2","textAndRectSize","mapWordFreqToTextAndRectSize","wordFreq","minWordFreq","maxWordFreq","fontsize","r","nodeRect","simulation","alpha","restart","myMinFontSize","myWeightage","parseFloat","myPower","powerthingk","powerthing","myWordFreq","k","Math","pow","myWord","correctPowerScaleDict","context","padding","console","log","font","bbox","measureText","nodes","wordGroups","groupName","nodeData","group_name","cluster","halfwidth","halfheight","isFoci","x","y","allClusters","allClustersWithWordCounts","Object","keys","c","wordcount","allClustersWithXY","size","radius","pack","children","sum","leaves","furthestr","indexOf","dataToNodes","filter","selectAll","enter","fociCirc","fociText","nodeTextGroup","alphaDecay","force","tickNode","fociQuadtree","addAll","forEach","getFurthestNodeDistFromFoci","nx1","nx2","ny1","ny2","visit","visited","x1","y1","x2","y2","l","sqrt","r1","r2","checkval","getFociByCluster","i","distances","val","nodeQuadtree","nn","changeY","changeX","React","processCsvContent","csvContent","preCsvArr","split","displayCsv","row","Boolean","item","slice","preJsonDict","join","jsonDict","JSON","parse","App","updateState","changedData","cleanedData","cleaneddata","myFiles","myFile","othernodes","random","newFile","fetch","then","res","getFile","className","updateParentState","stringify","Component","window","location","hostname","match","ReactDOM","render","StrictMode","navigator","serviceWorker","ready","registration","unregister","catch","error","message"],"mappings":"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","file":"static/js/main.3eec9a4a.chunk.js","sourcesContent":["const COLOR_SWATCH2 = [\n    '#e6194B',\n    '#3cb44b',\n    '#cc9a00',\n    '#4363d8',\n    '#f58231',\n    '#911eb4',\n    '#42d4f4',\n    '#f032e6',\n    '#bfef45',\n    '#fabebe',\n    '#469990',\n    '#e6beff',\n    '#9A6324',\n    '#fffac8',\n    '#800000',\n    '#aaffc3',\n    '#808000',\n    '#ffd8b1',\n    '#000075',\n    '#a9a9a9',\n]\n\nconst COLOR_SWATCH333 = [\n    '#ccffdf',\n    '#99ffbe',\n    '#64ff9e',\n    '#ccfff7',\n    '#99fff0',\n    '#66ffe8',\n    '#ccf8ff',\n    '#99f1ff',\n    '#66ebff',\n    '#ccebff',\n    '#99d8ff',\n    '#66c4ff',\n    '#ccffe0',\n    '#99ffc2',\n    '#66ffa3',\n]\n\nexport const COLOR_SWATCH = [\n    '#c2cdd8',\n    '#a1a9b4',\n    '#3881b8',\n    '#235174',\n    '#1d2b49',\n]\n","import * as React from 'react';\nimport * as d3 from 'd3';\nimport { COLOR_SWATCH } from '../constants.js';\n\nclass VizBox extends React.Component {\n    constructor(props) {\n        super(props);\n        this.state = {\n            data: this.props.data.categories,\n            dict: this.props.data.jsondict,\n            id: this.props.id,\n        }\n    }\n\n    componentDidMount() {\n        this.draw();\n    }\n\n    componentDidUpdate() {\n        this.draw();\n    }\n\n    componentWillReceiveProps(nextProps) {\n        this.setState({\n            data: nextProps.data.categories,\n            dict: nextProps.data.jsondict,\n        })\n    }\n\n    render() {\n        const { id } = this.state;\n        const vizboxname = \"vizbox\" + id.toString();\n        return (\n            <div>\n                <div>\n                    <button onClick={this.toggleBigCircleFill}>toggle big circle fill</button>\n                    <button onClick={this.toggleBigCircleLine}>toggle big circle line</button>\n                    <button onClick={this.toggleSmallCircleFill}>toggle small circle fill</button>\n                    <button onClick={this.toggleSmallCircleLine}>toggle small circle line</button>\n                </div>\n                {id.toString() === \"1\" &&\n                    <div style={{fontSize:\"11px\"}}>\n                        <div><label>max font size: </label><input id=\"maxfontsize1\" type=\"range\" min=\"10\" max=\"100\"></input><span id=\"readmaxfontsize1\"></span></div>\n                        <div><label>min font size: </label><input id=\"minfontsize1\" type=\"range\" min=\"10\" max=\"100\"></input><span id=\"readminfontsize1\"></span></div>\n                        <div><label>weightage...: </label><input id=\"weightage\" type=\"range\" min=\"0\" max=\"10\"></input><span id=\"readweightage\"></span></div>\n                        <div>info: basically a weighted power law distribution.</div>\n                    </div>}\n                {id.toString() === \"2\" &&\n                    <div style={{fontSize:\"11px\"}}>\n                        <div><label>max font size: </label><input id=\"maxfontsize2\" type=\"range\" min=\"10\" max=\"100\"></input><span id=\"readmaxfontsize2\"></span></div>\n                        <div><label>min font size: </label><input id=\"minfontsize2\" type=\"range\" min=\"10\" max=\"100\"></input><span id=\"readminfontsize2\"></span></div>\n                        <div><label>power: </label><input id=\"power\" type=\"range\" min=\"1\" max=\"10\"></input><span id=\"readpower\"></span></div>\n                        <div>info: slightly different, exponential distribution. sorry, its a bit hard to type out the formulas here, so the first one uses a combination of power law on the ordinal frequency ranking of the word, with the weight being how much weight is on the ordinal ranking and away from using absolute/relative frequency to calculate it. this second one is a slightly different exponential distribution, the power refers to the exponent, not the weightage.</div>\n                    </div>}\n                {id.toString() === \"3\" &&\n                    <div style={{fontSize:\"11px\"}}>\n                        <div><label>max font size: </label><input id=\"maxfontsize3\" type=\"range\" min=\"10\" max=\"100\"></input><span id=\"readmaxfontsize3\"></span></div>\n                        <div><label>min font size: </label><input id=\"minfontsize3\" type=\"range\" min=\"10\" max=\"100\"></input><span id=\"readminfontsize3\"></span></div>\n                        <div>info: linear</div>\n                    </div>}\n                <div id={vizboxname} style={{margin: \"50px\", backgroundColor: \"white\", minWidth:\"500px\", outline: \"2px solid black\"}}>\n                </div>\n            </div>\n        )\n    }\n\n    toggleBigCircleFill = () => {\n        for (let f of this.fociData) {\n            f.focibigcirccolor = (f.focibigcirccolor === f.color ? \"none\" : f.color);\n        }\n        this.fociBigCirc.attr(\"fill\", d => d.focibigcirccolor);\n    }\n\n    toggleBigCircleLine = () => {\n        for (let f of this.fociData) {\n            f.focibigcircleline = (f.focibigcircleline === 1.5 ? 0 : 1.5);\n        }\n        this.fociBigCirc.attr(\"stroke-width\", d => d.focibigcircleline);\n    }\n\n    toggleSmallCircleFill = () => {\n        for (let n of this.nodesData) {\n            n.nodecirclefill = (n.nodecirclefill === n.color ? \"none\" : n.color);\n        }\n        this.nodeCirc.attr(\"fill\", d => d.nodecirclefill);\n    }\n\n    toggleSmallCircleLine = () => {\n        for (let n of this.nodesData) {\n            n.nodecircleline = (n.nodecircleline === 1.5 ? 0 : 1.5);\n        }\n        this.nodeCirc.attr(\"stroke-width\", d => d.nodecircleline);\n    }\n\n    draw() {\n\n        if (this.state.data === undefined || this.state.data.length === 0) {\n            return;\n        }\n\n        d3.select(\"#vizbox\" + this.state.id.toString()).select(\"svg\").remove();\n\n        // -- set up empty svg ---\n        this.height = 600;\n        this.width = 800;\n        this.ctx = document.createElement(\"canvas\").getContext(\"2d\");\n        this.clusterPadding = 30;\n        this.nodePadding = 30;\n        let that = this; // for simulation closure\n\n        this.svg = d3.select(\"#vizbox\" + this.state.id.toString())\n                        .append(\"svg\")\n                        .attr(\"viewBox\", `0 0 ${this.width} ${this.height}`)\n                        .call(d3.zoom()\n                                .on(\"zoom\", function() {\n                                    that.foci.attr(\"transform\", d3.event.transform);\n                                    that.node.attr(\"transform\", d3.event.transform);\n                                }));\n\n        // --- utility functions ---\n        /*let mapWordFreqToTextAndRectSize = (myWord, myWordFreq, minWordFreq, maxWordFreq, context = this.ctx, minFontSize = 14, maxFontSize = 32, padding = 10) => {\n            myWord = myWord + \"aa\"; // to account for the close button\n            let fontSize = mapWordFreqToFontSize(myWordFreq, minWordFreq, maxWordFreq);\n            context.font = fontSize + \"px sans-serif\";\n\n            let bbox = {};\n            bbox.width = context.measureText(myWord).width;\n            bbox.height = context.measureText(\"M\").width;\n            \n            return {\n                fontsize: fontSize,\n                width: bbox.width + padding,\n                height: bbox.height + padding\n            };\n        }*/\n        // for scaling examples\n        let myrs = 0.5;\n        let mymaxfontsize = 60;\n        let myminfontsize = 10;\n        let  producePowerScale = (rs, maxFontSize, minFontSize) => {\n            let wordsWithFreqs = [];\n            for (let group of this.state.data) {\n                for (let word of group.words) {\n                    if (!(wordsWithFreqs.map(d => d[0]).includes(word))) {\n                        wordsWithFreqs.push([word, this.state.dict[word]]);\n                    }\n                }\n            }\n            wordsWithFreqs.sort((a, b) => b[1] - a[1]);\n            let justFreqs = [...new Set(wordsWithFreqs.map(d => d[1]))]\n            justFreqs.sort((a, b) => b - a);\n            let myMaxFreq = justFreqs[0];\n            justFreqs = justFreqs.map(d => [d, d/myMaxFreq]);\n            \n            let lastFreq = 1;\n            let fontSize = maxFontSize;\n            let freqWithFontSize = {};\n            for (let ff of justFreqs) {\n                // oops, where freq is wf[2], forgot to annotate, lazy change\n                fontSize = ~~((rs * (ff[1] / lastFreq)) + ((1 - rs) * fontSize))\n                fontSize = fontSize < minFontSize ? minFontSize : fontSize;\n                freqWithFontSize[ff[0].toString()] = fontSize;\n                lastFreq = ff[1];\n            }\n            \n            // returns dict with word count keys and font size values\n            return freqWithFontSize;\n\n        }\n\n        this.powerScaleDict = producePowerScale(myrs, mymaxfontsize, myminfontsize);\n        \n        // sliders\n        if (this.state.id.toString() === \"1\") {\n            d3.select(\"#maxfontsize1\").on(\"input\", () => {\n                let myMaxFontSize = document.getElementById(\"maxfontsize1\").value * 4;\n                d3.select(\"#readmaxfontsize1\").text(myMaxFontSize.toString());\n                mymaxfontsize = parseInt(myMaxFontSize);\n                this.powerScaleDict2 = producePowerScale(myrs, mymaxfontsize, myminfontsize);\n                for (let n of this.nodesData) {\n                    let textAndRectSize = mapWordFreqToTextAndRectSize(n.word, n.wordFreq, this.minWordFreq, this.maxWordFreq, this.powerScaleDict2)\n                    n.height = textAndRectSize.height;\n                    n.width = textAndRectSize.width;\n                    //console.log(\"old font size\", n.fontsize);\n                    n.fontsize = textAndRectSize.fontsize;\n                    //console.log(\"new font size\", n.fontsize);\n                    n.r = ~~(n.width/2 + n.height/2);\n                }\n\n                this.nodeCirc.attr(\"r\", d => d.r);\n                \n                this.nodeRect.attr(\"width\", d => d.width)\n                                .attr(\"height\", d => d.height)\n\n                this.node.select(\"text\")\n                                .attr(\"font-size\", d => d.fontsize)\n                \n                this.node.select(\"tspan\")\n                                .attr(\"font-size\", d => d.fontsize*0.8)\n\n                this.simulation.alpha(0.2).restart();\n\n\n            });\n            d3.select(\"#minfontsize1\").on(\"input\", () => {\n                let myMinFontSize = document.getElementById(\"minfontsize1\").value / 2;\n                d3.select(\"#readminfontsize1\").text(myMinFontSize.toString());\n                myminfontsize = parseInt(myMinFontSize);\n                this.powerScaleDict2 = producePowerScale(myrs, mymaxfontsize, myminfontsize);\n                for (let n of this.nodesData) {\n                    let textAndRectSize = mapWordFreqToTextAndRectSize(n.word, n.wordFreq, this.minWordFreq, this.maxWordFreq, this.powerScaleDict2)\n                    n.height = textAndRectSize.height;\n                    n.width = textAndRectSize.width;\n                    n.fontsize = textAndRectSize.fontsize;\n                    n.r = ~~(n.width/2 + n.height/2);\n                }\n\n                this.nodeCirc.attr(\"r\", d => d.r);\n                \n                this.nodeRect.attr(\"width\", d => d.width)\n                                .attr(\"height\", d => d.height)\n\n                this.node.select(\"text\")\n                                .attr(\"font-size\", d => d.fontsize)\n                \n                this.node.select(\"tspan\")\n                                .attr(\"font-size\", d => d.fontsize*0.8)\n\n                this.simulation.alpha(0.2).restart();\n\n\n\n            });\n            d3.select(\"#weightage\").on(\"input\", () => {\n                let myWeightage = document.getElementById(\"weightage\").value / 10;\n                d3.select(\"#readweightage\").text((1 - myWeightage).toString());\n                myrs = parseFloat(myWeightage);\n                this.powerScaleDict2 = producePowerScale(myrs, mymaxfontsize, myminfontsize);\n                for (let n of this.nodesData) {\n                    let textAndRectSize = mapWordFreqToTextAndRectSize(n.word, n.wordFreq, this.minWordFreq, this.maxWordFreq, this.powerScaleDict2)\n                    n.height = textAndRectSize.height;\n                    n.width = textAndRectSize.width;\n                    n.fontsize = textAndRectSize.fontsize;\n                    n.r = ~~(n.width/2 + n.height/2);\n                }\n\n                this.nodeCirc.attr(\"r\", d => d.r);\n                \n                this.nodeRect.attr(\"width\", d => d.width)\n                                .attr(\"height\", d => d.height)\n\n                this.node.select(\"text\")\n                                .attr(\"font-size\", d => d.fontsize)\n                \n                this.node.select(\"tspan\")\n                                .attr(\"font-size\", d => d.fontsize*0.8)\n\n                this.simulation.alpha(0.2).restart();\n\n\n\n            });\n        } \n\n        if (this.state.id.toString() === \"2\") {\n            d3.select(\"#maxfontsize2\").on(\"input\", () => {\n                let myMaxFontSize = document.getElementById(\"maxfontsize2\").value * 4;\n                d3.select(\"#readmaxfontsize2\").text(myMaxFontSize.toString());\n                mymaxfontsize = parseInt(myMaxFontSize);\n                for (let n of this.nodesData) {\n                    let textAndRectSize = mapWordFreqToTextAndRectSize(n.word, n.wordFreq, this.minWordFreq, this.maxWordFreq, \"\", this.ctx, myminfontsize, mymaxfontsize)\n                    n.height = textAndRectSize.height;\n                    n.width = textAndRectSize.width;\n                    n.fontsize = textAndRectSize.fontsize;\n                    n.r = ~~(n.width/2 + n.height/2);\n                }\n\n                this.nodeCirc.attr(\"r\", d => d.r);\n                \n                this.nodeRect.attr(\"width\", d => d.width)\n                                .attr(\"height\", d => d.height)\n\n                this.node.select(\"text\")\n                                .attr(\"font-size\", d => d.fontsize)\n                \n                this.node.select(\"tspan\")\n                                .attr(\"font-size\", d => d.fontsize*0.8)\n\n                this.simulation.alpha(0.2).restart();\n            });\n\n            d3.select(\"#minfontsize2\").on(\"input\", () => {\n                let myMinFontSize = document.getElementById(\"minfontsize2\").value / 2;\n                d3.select(\"#readminfontsize2\").text(myMinFontSize.toString());\n                myminfontsize = parseInt(myMinFontSize);\n                for (let n of this.nodesData) {\n                    let textAndRectSize = mapWordFreqToTextAndRectSize(n.word, n.wordFreq, this.minWordFreq, this.maxWordFreq, \"\", this.ctx, myminfontsize, mymaxfontsize)\n                    n.height = textAndRectSize.height;\n                    n.width = textAndRectSize.width;\n                    n.fontsize = textAndRectSize.fontsize;\n                    n.r = ~~(n.width/2 + n.height/2);\n                }\n\n                this.nodeCirc.attr(\"r\", d => d.r);\n                \n                this.nodeRect.attr(\"width\", d => d.width)\n                                .attr(\"height\", d => d.height)\n\n                this.node.select(\"text\")\n                                .attr(\"font-size\", d => d.fontsize)\n                \n                this.node.select(\"tspan\")\n                                .attr(\"font-size\", d => d.fontsize*0.8)\n\n                this.simulation.alpha(0.2).restart();\n            });\n\n            d3.select(\"#power\").on(\"input\", () => {\n                let myPower = document.getElementById(\"power\").value;\n                d3.select(\"#readpower\").text(myPower.toString());\n                powerthingk = parseFloat(myPower);\n                for (let n of this.nodesData) {\n                    let textAndRectSize = mapWordFreqToTextAndRectSize(n.word, n.wordFreq, this.minWordFreq, this.maxWordFreq, \"\", this.ctx, myminfontsize, mymaxfontsize)\n                    n.height = textAndRectSize.height;\n                    n.width = textAndRectSize.width;\n                    n.fontsize = textAndRectSize.fontsize;\n                    n.r = ~~(n.width/2 + n.height/2);\n                }\n\n                this.nodeCirc.attr(\"r\", d => d.r);\n                \n                this.nodeRect.attr(\"width\", d => d.width)\n                                .attr(\"height\", d => d.height)\n\n                this.node.select(\"text\")\n                                .attr(\"font-size\", d => d.fontsize)\n                \n                this.node.select(\"tspan\")\n                                .attr(\"font-size\", d => d.fontsize*0.8)\n\n                this.simulation.alpha(0.2).restart();\n            });\n\n        }\n\n        if (this.state.id.toString() === \"3\") {\n            d3.select(\"#maxfontsize3\").on(\"input\", () => {\n                let myMaxFontSize = document.getElementById(\"maxfontsize3\").value * 4;\n                d3.select(\"#readmaxfontsize3\").text(myMaxFontSize.toString());\n                mymaxfontsize = parseInt(myMaxFontSize);\n                for (let n of this.nodesData) {\n                    let textAndRectSize = mapWordFreqToTextAndRectSize(n.word, n.wordFreq, this.minWordFreq, this.maxWordFreq, \"\", this.ctx, myminfontsize, mymaxfontsize)\n                    n.height = textAndRectSize.height;\n                    n.width = textAndRectSize.width;\n                    n.fontsize = textAndRectSize.fontsize;\n                    n.r = ~~(n.width/2 + n.height/2);\n                }\n\n                this.nodeCirc.attr(\"r\", d => d.r);\n                \n                this.nodeRect.attr(\"width\", d => d.width)\n                                .attr(\"height\", d => d.height)\n\n                this.node.select(\"text\")\n                                .attr(\"font-size\", d => d.fontsize)\n                \n                this.node.select(\"tspan\")\n                                .attr(\"font-size\", d => d.fontsize*0.8)\n\n                this.simulation.alpha(0.2).restart();\n            });\n\n            d3.select(\"#minfontsize3\").on(\"input\", () => {\n                let myMinFontSize = document.getElementById(\"minfontsize3\").value /2;\n                d3.select(\"#readminfontsize3\").text(myMinFontSize.toString());\n                myminfontsize = parseInt(myMinFontSize);\n                for (let n of this.nodesData) {\n                    let textAndRectSize = mapWordFreqToTextAndRectSize(n.word, n.wordFreq, this.minWordFreq, this.maxWordFreq, \"\", this.ctx, myminfontsize, mymaxfontsize)\n                    n.height = textAndRectSize.height;\n                    n.width = textAndRectSize.width;\n                    n.fontsize = textAndRectSize.fontsize;\n                    n.r = ~~(n.width/2 + n.height/2);\n                }\n\n                this.nodeCirc.attr(\"r\", d => d.r);\n                \n                this.nodeRect.attr(\"width\", d => d.width)\n                                .attr(\"height\", d => d.height)\n\n                this.node.select(\"text\")\n                                .attr(\"font-size\", d => d.fontsize)\n                \n                this.node.select(\"tspan\")\n                                .attr(\"font-size\", d => d.fontsize*0.8)\n\n                this.simulation.alpha(0.2).restart();\n            });\n\n        }\n\n        let powerthing = (myWordFreq, maxFontSize, minFontSize, maxWordFreq, minWordFreq, k) => {\n            return Math.pow((((Math.pow(maxFontSize, k))*(myWordFreq - minWordFreq)/maxWordFreq) + Math.pow(minFontSize, k)), 1/k);\n            //return (((maxFontSize**2)*(myWordFreq - minWordFreq)/maxWordFreq) + minFontSize**2)**0.5;\n        }\n        \n        let powerthingk = 2;\n\n        let mapWordFreqToTextAndRectSize = (myWord, myWordFreq, minWordFreq, maxWordFreq, correctPowerScaleDict, context = this.ctx, minFontSize = 14, maxFontSize = 32, padding = 10) => {\n            console.log(\"running this\", this.state.id.toString())\n\n            let fontSize;\n            switch (this.state.id.toString()) {\n                case \"1\":\n                    fontSize = correctPowerScaleDict[myWordFreq.toString()];\n                    break;\n                case \"2\":\n                    //fontSize = (((maxFontSize**2)*(myWordFreq - minWordFreq)/maxWordFreq) + minFontSize**2)**0.5;\n                    fontSize = powerthing(myWordFreq, maxFontSize, minFontSize, maxWordFreq, minWordFreq, powerthingk);\n                    break;\n                case \"3\":\n                    fontSize = (((myWordFreq - minWordFreq)/maxWordFreq)*(maxFontSize - minFontSize))*2 + minFontSize\n                    break; \n                default:\n                    fontSize = 11;\n                    console.log(\"fucked up somewhere\");\n                    \n            }\n            myWord = myWord + \"aa\"; // to account for the close button\n            //let fontSize = mapWordFreqToFontSize(myWordFreq, minWordFreq, maxWordFreq);\n            context.font = fontSize + \"px sans-serif\";\n\n            let bbox = {};\n            bbox.width = context.measureText(myWord).width;\n            bbox.height = context.measureText(\"M\").width;\n            \n            return {\n                fontsize: fontSize,\n                width: bbox.width + padding,\n                height: bbox.height + padding\n            };\n        }\n\n        /*let mapWordFreqToFontSize = (myWordFreq, minWordFreq, maxWordFreq, minFontSize = 14, maxFontSize = 32) => {\n        // this is the scaling function, currently linear scaling\n            return (((myWordFreq - minWordFreq)/maxWordFreq)*(maxFontSize - minFontSize))*2 + minFontSize\n        }*/\n\n        let mapClusterToColour = (cluster) => {\n            return COLOR_SWATCH[that.allClusters.indexOf(cluster) % COLOR_SWATCH.length];\n        }\n\n        let dataToNodes = (data) => {\n            let wordGroups = data;\n            let groupName = \"\";\n            let nodeData = [];\n\n            // normal nodes\n            for (let group of wordGroups) {\n                groupName = group.group_name;\n                let words = group.words;\n                for (let word of words) {\n                    nodeData.push({\n                                word: word,\n                                wordFreq: +this.state.dict[word],\n                                cluster: groupName,\n                            });\n                }\n            }\n\n            this.minWordFreq = Math.min(...nodeData.map( d => d.wordFreq ))\n            this.maxWordFreq = Math.max(...nodeData.map( d => d.wordFreq ))\n\n            let halfwidth = ~~this.width/2;\n            let halfheight = ~~this.height/2;\n\n            for (let n of nodeData) {\n                let textAndRectSize = mapWordFreqToTextAndRectSize(n.word, n.wordFreq, this.minWordFreq, this.maxWordFreq, this.powerScaleDict)\n                n.height = textAndRectSize.height;\n                n.width = textAndRectSize.width;\n                n.fontsize = textAndRectSize.fontsize;\n                n.isFoci = false;\n                n.x = halfwidth;\n                n.y = halfheight;\n                n.r = ~~(n.width/2 + n.height/2);\n                n.nodecirclefill = \"none\";\n                n.nodecircleline = 0;\n            }\n\n            // foci\n            let allClusters = [];\n            let allClustersWithWordCounts = {};\n            for (let n of nodeData) {\n                if (!allClusters.includes(n.cluster)) {\n                    allClusters.push(n.cluster);\n                    //allClustersWithWordCounts[n.cluster] = n.wordFreq;\n                    allClustersWithWordCounts[n.cluster] = 1;\n                } else {\n                    //allClustersWithWordCounts[n.cluster] += n.wordFreq;\n                    allClustersWithWordCounts[n.cluster] += 1;\n                }\n            }\n\n            this.allClusters = allClusters;\n            this.allClusters.sort();\n\n            // initialize locations of foci\n            allClustersWithWordCounts = Object.keys(allClustersWithWordCounts).map(c => ({cluster: c, wordcount: allClustersWithWordCounts[c]}));\n\n            let pack = d3.pack()\n                            .size([this.width, this.height])\n                            .radius(d => d.value)\n                            .padding(0);\n\n            let hier = d3.hierarchy({children: allClustersWithWordCounts})\n                            .sum(d => { let arbitraryNum = 1; return arbitraryNum*d.wordcount} );\n            let allClustersWithXY = pack(hier).leaves().map(d => ({ cluster: d.data.cluster, r: d.r, x: d.x, y: d.y }));\n\n            for (let f of allClustersWithXY) {\n                f.r = 20; // replace r with default radius size\n                f.furthestr = f.r;\n                f.color = mapClusterToColour(f.cluster);\n                f.isFoci = true;\n                f.focibigcirccolor = \"none\";\n                f.focibigcircleline = 1.5;\n                \n                for (let n of nodeData) {\n                    (n.cluster === f.cluster ) && (n.color = f.color);\n                }\n            }\n            \n            let fociData = allClustersWithXY;\n\n            return [...nodeData, ...fociData]\n            // node: word, wordFreq, fontsize, cluster, height, width, isFoci, color, x, y\n            // foci: cluster, r, isFoci, color, x, y\n        }\n\n        this.nodes = dataToNodes(this.state.data);\n        \n        this.nodesData = this.nodes.filter(d => !d.isFoci);\n\n        this.fociData = this.nodes.filter(d => d.isFoci);\n        \n        this.foci = this.svg\n                        .selectAll(\".foci\")\n                        .data(this.fociData)\n                        .enter()\n                        .append(\"g\")\n                        .attr(\"class\", \"foci\")\n\n        this.fociBigCirc = this.foci.append(\"circle\")\n                                    .attr(\"r\", d => d.furthestr)\n                                    //.attr(\"fill\", d => d.color)\n                                    .attr(\"fill\", d => d.focibigcirccolor)\n                                    .attr(\"fill-opacity\", 0.1)\n                                    .attr(\"stroke-width\", d => d.focibigcircleline)\n                                    .attr(\"stroke\", d => d.color)\n\n        this.fociCirc = this.foci.append(\"circle\")\n                                    .attr(\"r\", d => d.r)\n                                    .attr(\"fill\", d => d.color)\n                                    .attr(\"fill-opacity\", 0.5)\n                                    .attr(\"stroke-width\", 1.5)\n                                    .attr(\"stroke\", d => d.color)\n                                    .attr(\"cx\", d => d.x)\n                                    .attr(\"cy\", d => d.y)\n\n        this.fociText = this.foci.append(\"text\")\n                                    .text(\"+\")\n                                    .attr(\"text-anchor\", \"middle\")\n                                    .attr(\"alignment-baseline\", \"middle\")\n                                    .attr(\"fill\", \"white\")\n                                    .attr(\"x\", d => d.x)\n                                    .attr(\"y\", d => d.y)\n\n        this.node = this.svg\n                        .selectAll(\".node\")\n                        .data(this.nodesData)\n                        .enter()\n                        .append(\"g\")\n                        .attr(\"class\", \"node\");\n\n        this.nodeCirc = this.node.append(\"circle\")\n                                .attr(\"fill\", d => d.nodecirclefill)\n                                .attr(\"fill-opacity\", 0.3)\n                                .attr(\"stroke-width\", d => d.nodecircleline)\n                                .attr(\"stroke\", d => d.color)\n                                .attr(\"cx\", d => d.x)\n                                .attr(\"cy\", d => d.y)\n                                .attr(\"r\", d => d.r)\n                                .attr(\"class\", \"thisnodecirc\");\n\n        this.nodeRect = this.node.append(\"rect\")\n                                .attr(\"width\", d => d.width)\n                                .attr(\"height\", d => d.height)\n                                .attr(\"rx\", 7)\n                                .attr(\"ry\", 7)\n                                .attr(\"fill\", \"white\")\n                                .attr(\"stroke-width\", 1.5)\n                                .attr(\"stroke\", d => d.color)\n                                .attr(\"x\", d => d.x - d.width/2)\n                                .attr(\"y\", d => d.y - d.height/2);\n\n        this.nodeTextGroup = this.node.append(\"g\")\n                                        .attr(\"font-size\", d => d.fontsize)\n                                        .append(\"text\")\n                                        .text( d => d.word)\n                                        .attr(\"fill\", d => d.color)\n                                        .style(\"text-anchor\", \"middle\")\n                                        .style(\"alignment-baseline\", \"middle\")\n                                        .append(\"tspan\")\n                                        .text(\"  \\u2716\")\n                                        .attr(\"font-size\", d => d.fontsize*0.8)\n                                        .style(\"text-anchor\", \"middle\")\n                                        .style(\"alignment-baseline\", \"central\")\n                                        .style(\"fill\", \"crimson\");\n\n\n        this.simulation = d3.forceSimulation()\n                            .alphaDecay(0.01)\n                            //.velocityDecay(0.1)\n                            //.force(\"x\", d3.forceX().strength(.004))\n                            //.force(\"y\", d3.forceY().strength(.004))\n                            .force(\"collide\", tickNode)\n                            .force(\"collide2\", tickFoci)\n                            //.force(\"manybody\", d3.forceManyBody().strength(200))\n                            //.force(\"center\", d3.forceCenter(~~this.width/2, ~~this.height/2))\n                            //.force(\"collide\", d3.forceCollide().radius(d => d.r))\n\n        this.simulation.nodes(this.nodes)\n                        //.on(\"tick\", ticked)\n                        //.on(\"tick.foci\", tickFoci)\n                        //.on(\"tick.node\", tickNode);\n\n        // --- utility functions ---\n        function getFurthestNodeDistFromFoci(foci) {\n            let captured = that.nodesData.filter(d => d.cluster === foci.cluster);\n            let distances = captured.map( d => ((d.x - foci.x)**2 + (d.y - foci.y)**2)**0.5 + d.r);\n            let result = Math.min(Math.max(...distances), 1000); // limit on size of foci\n            return result;\n        }\n\n        let getFociByCluster = (cluster) => {\n            for (let i = 0; i < this.fociData.length; i++) {\n                if (this.fociData[i].cluster === cluster) return this.fociData[i];\n            }\n        }\n\n        function checkval(val) {\n            if (!((val < 0) || (val > 0) || (val === 0))) {\n                console.log(val);\n                debugger;\n            }\n        }\n\n        // --- end utility functions ---\n\n        function tickFoci(alpha) {\n            //let k = this.alpha() * 0.1;\n            let k = alpha;\n\n            let fociData = that.fociData;\n\n            const fociQuadtree = d3.quadtree()\n                                    .x(d => d.x)\n                                    .y(d => d.y)\n                                    .addAll(fociData);\n\n            fociData.forEach(function(f) {\n                console.log(\"asked to collide by\", that.state.id.toString())\n                \n                // foci collision\n                let r = f.r + 2*getFurthestNodeDistFromFoci(f),\n                    nx1 = f.x - r,\n                    nx2 = f.x + r,\n                    ny1 = f.y - r,\n                    ny2 = f.y + r;\n\n                fociQuadtree.visit((visited, x1, y1, x2, y2) => {\n                    if (visited.data && (visited.data !== f)) {\n                        let x = f.x - visited.data.x,\n                            y = f.y - visited.data.y,\n                            //l = Math.max(0.0001, Math.sqrt(x*x + y*y)),\n                            l = Math.sqrt(x*x + y*y),\n                            r1 = getFurthestNodeDistFromFoci(f),\n                            r2 = getFurthestNodeDistFromFoci(visited.data);\n                            //r1 = 50, r2 = 50;\n                            r = r1 + r2 + that.clusterPadding;\n\n                        if (l < r) {\n                            l = (l - r) / l * k;\n\n                            f.x -= x *= l;\n                            f.y -= y *= l;\n                            visited.data.x += x;\n                            visited.data.y += y;\n\n                            checkval(x); checkval(y); checkval(visited.data.x); checkval(visited.data.y); checkval(f.x); checkval(f.y);\n                        } else if (l > (3.2*r)) {\n                            l = (l - r)/l * k; // l > r\n                            f.x -= x *= l;\n                            f.y -= y *= l;\n                            visited.data.x += x;\n                            visited.data.y += y;\n                        }\n\n                        f.furthestr = r1 + that.clusterPadding/2;\n                        visited.data.furthestr = r2 + that.clusterPadding/2;\n\n                    }\n\n                    return x1 > nx2 || x2 < nx1 || y1 > ny2 || y2 < ny1;\n                });\n            });\n\n            that.fociBigCirc.attr(\"r\", d => d.furthestr)\n                            .attr(\"cx\", d => d.x)\n                            .attr(\"cy\", d => d.y);\n\n            that.fociCirc.attr(\"cx\", d => d.x)\n                        .attr(\"cy\", d => d.y);\n\n            that.fociText.attr(\"x\", d => d.x)\n                        .attr(\"y\", d => d.y);\n\n            that.simulation.force(\"collide\", tickNode);\n\n        }\n\n        function tickNode(alpha) {\n            //let k = this.alpha() * 0.5;\n            let k = alpha;\n            let nodes = that.nodes;\n\n            const nodeQuadtree = d3.quadtree()\n                                    .x(d => d.x)\n                                    .y(d => d.y)\n                                    .addAll(nodes)\n\n            nodes.forEach(function(n) {\n                // node collision\n                let r = 2*n.r,\n                    nx1 = n.x - r,\n                    nx2 = n.x + r,\n                    ny1 = n.y - r,\n                    ny2 = n.y + r;\n\n                nodeQuadtree.visit((visited, x1, y1, x2, y2) => {\n                    if (visited.data && (visited.data !== n)) {\n                        let x = n.x - visited.data.x,\n                            y = n.y - visited.data.y,\n                            l = Math.sqrt(x*x + y*y),\n                            r1 = n.r,\n                            r2 = visited.data.r,\n                            r = r1 + r2 + that.nodePadding;\n\n                        if (l < r) {\n                            l = (l - r) / l * k;\n\n                            n.x -= x *= l;\n                            n.y -= y *= l;\n\n                            if (!(visited.data.isFoci)) {\n                                visited.data.x += x;\n                                visited.data.y += y;\n                            }\n\n                            checkval(x); checkval(y); checkval(visited.data.x); checkval(visited.data.y); checkval(n.x); checkval(n.y);\n                        }\n\n                    }\n\n                    return x1 > nx2 || x2 < nx1 || y1 > ny2 || y2 < ny1;\n                });\n            });\n\n\n            // interlude - directing nodes to foci\n            for (let nn of nodes) {\n\n                let changeY = (getFociByCluster(nn.cluster).y - nn.y) * k * 2;\n                let changeX = (getFociByCluster(nn.cluster).x - nn.x) * k * 2;\n                //n.y += (getFociByCluster(n.cluster).y - n.y) * k;\n                //n.x += (getFociByCluster(n.cluster).x - n.x) * k;\n                checkval(nn.x); checkval(nn.y); checkval(changeX); checkval(changeY);\n                nn.y += changeY;\n                nn.x += changeX;\n                checkval(nn.x); checkval(nn.y);\n            }\n\n            // end interlude\n\n\n            that.nodeCirc.attr(\"cx\", d => d.x)\n                        .attr(\"cy\", d => d.y);\n\n            that.nodeRect.attr(\"x\", d => d.x - d.width/2)\n                        .attr(\"y\", d => d.y - d.height/2);\n\n            that.node.select(\"text\")\n                        .attr(\"x\", d => d.x)\n                        .attr(\"y\", d => d.y);\n\n        }\n\n        /*function ticked() {\n            let k = this.alpha() * 0.5;\n\n            let fociData = that.fociData;\n\n            const fociQuadtree = d3.quadtree()\n                                    .x(d => d.x)\n                                    .y(d => d.y)\n                                    .addAll(fociData);\n\n            fociData.forEach(function(f) {\n                \n                // foci collision\n                let r = f.r,\n                    nx1 = f.x - r,\n                    nx2 = f.x + r,\n                    ny1 = f.y - r,\n                    ny2 = f.y + r;\n\n                fociQuadtree.visit((visited, x1, y1, x2, y2) => {\n                    if (visited.data && (visited.data !== f)) {\n                        let x = f.x - visited.data.x,\n                            y = f.y - visited.data.y,\n                            l = Math.sqrt(x*x + y*y),\n                            r1 = getFurthestNodeDistFromFoci(f),\n                            r2 = getFurthestNodeDistFromFoci(visited.data);\n                            //r1 = 50, r2 = 50;\n                            r = r1 + r2 + that.clusterPadding;\n\n                        if (l < r) {\n                            console.log(`${f.cluster} and ${visited.data.cluster} are too close tgt`);\n                            l = (l - r) / l * k;\n\n                            f.x -= x *= l;\n                            f.y -= y *= l;\n                            visited.data.x += x;\n                            visited.data.y += y;\n\n                            checkval(x); checkval(y); checkval(visited.data.x); checkval(visited.data.y); checkval(f.x); checkval(f.y);\n                        }\n\n                    }\n\n                    return x1 > nx2 || x2 < nx1 || y1 > ny2 || y2 < ny1;\n                });\n            });\n\n            that.fociCirc.attr(\"cx\", d => d.x)\n                        .attr(\"cy\", d => d.y);\n\n            that.fociText.attr(\"x\", d => d.x)\n                        .attr(\"y\", d => d.y);\n\n            let nodesData = that.nodesData;\n\n            const nodeQuadtree = d3.quadtree()\n                                    .x(d => d.x)\n                                    .y(d => d.y)\n                                    .addAll(that.nodes)\n\n//            nodes.forEach(function(n) {\n            for (let n of nodesData) {\n\n                if (n.isFoci) {\n                    return;\n                }\n\n                let updated = true;\n\n                // node RECT collision\n                nodeQuadtree.visit((visited, x1, y1, x2, y2) => {\n\n                    if (visited.data && (visited.data !== n)) {\n\n                        if (visited.data.isFoci) {\n                            let x = n.x - visited.data.x,\n                                y = n.y - visited.data.y,\n                                xSpacing = visited.data.r + n.width/2,\n                                ySpacing = visited.data.r + n.height/2,\n                                absX = Math.abs(x),\n                                absY = Math.abs(y),\n                                l,\n                                lx,\n                                ly;\n\n                            if (( absX < xSpacing ) && ( absY < ySpacing )) {\n                                l = Math.max(0.001, Math.sqrt(x*x + y*y));\n\n                                lx = (absX - xSpacing) / l;\n                                ly = (absY - ySpacing) / l;\n\n                                if (Math.abs(lx) > Math.abs(ly)) {\n                                    lx = 0;\n                                } else {\n                                    ly = 0;\n                                }\n\n                                n.x -= x *= lx\n                                n.y -= y *= ly;\n                                //visited.data.x += x; // foci do not move\n                                //visited.data.y += y;\n                                checkval(x); checkval(y); checkval(n.x); checkval(n.y);\n\n                                //updated = true;\n                                updated = false; // optimize later\n\n                            }\n                        } else { // !visited.data.isFoci\n\n                            let x = n.x - visited.data.x,\n                                y = n.y - visited.data.y,\n                                xSpacing = ~~(visited.data.width + n.width)/2,\n                                ySpacing = ~~(visited.data.height + n.height)/2,\n                                absX = Math.abs(x),\n                                absY = Math.abs(y),\n                                l,\n                                lx,\n                                ly;\n\n\n                            if (( absX < xSpacing ) && ( absY < ySpacing )) {\n                                l = Math.max(0.001, Math.sqrt(x*x + y*y));\n\n                                lx = (absX - xSpacing) / l;\n                                ly = (absY - ySpacing) / l;\n\n                                if (Math.abs(lx) > Math.abs(ly)) {\n                                    lx = 0;\n                                } else {\n                                    ly = 0;\n                                }\n\n                                n.x -= ~~(x *= lx);\n                                n.y -= ~~(y *= ly);\n                                visited.data.x += ~~x;\n                                visited.data.y += ~~y;\n\n                            checkval(x); checkval(y); checkval(visited.data.x); checkval(visited.data.y); checkval(n.x); checkval(n.y);\n                                //updated = true;\n                                updated = false; // optimize later\n\n                            }\n                        }\n                    }\n                    return false;\n\n                });\n\n\n            // interlude - directing nodes to foci\n            for (let nn of nodesData) {\n\n                let changeY = (getFociByCluster(nn.cluster).y - nn.y) * k;\n                let changeX = (getFociByCluster(nn.cluster).x - nn.x) * k\n                //n.y += (getFociByCluster(n.cluster).y - n.y) * k;\n                //n.x += (getFociByCluster(n.cluster).x - n.x) * k;\n                checkval(nn.x); checkval(nn.y); checkval(changeX); checkval(changeY);\n                nn.y += changeY;\n                nn.x += changeX;\n                checkval(nn.x); checkval(nn.y);\n            }\n\n            // end interlude\n\n            that.nodeRect.attr(\"x\", d => d.x - d.width/2)\n                    .attr(\"y\", d => d.y - d.height/2);\n\n            that.node.select(\"text\")\n                                .attr(\"x\", d => d.x)\n                                .attr(\"y\", d => d.y)\n\n            };\n\n    }*/\n\n\n\n    }\n}\n\nexport default VizBox;\n","import React from 'react';\nimport VizBox from './VizBox';\nimport * as d3 from 'd3';\n//import textStyle from 'style1.module.css';\n//import vizBoxStyle from 'style2.module.css';\n\nfunction csvToArray(csvstr){\n    let rows = csvstr.split(\"\\n\");\n    return rows.map( row => row.split(\",\"));\n}\n\nfunction processCsvContent(csvContent){\n    let preCsvArr = csvContent.split(\"<$$$$$>\");\n    let displayCsv = csvToArray(preCsvArr[0]);\n    displayCsv = displayCsv.map(row => row.filter(Boolean));\n    displayCsv = displayCsv.filter(item => item.length > 2);\n    displayCsv = displayCsv.slice(1);\n    displayCsv = displayCsv.map(row => row.slice(2));\n\n    let preJsonDict = preCsvArr[1].split('\\n').join('');\n    let jsonDict = JSON.parse(preJsonDict);\n    let alt = displayCsv.map( group => ({group_name: group[0], words: group}));\n\n    return ({categories: alt, jsondict: jsonDict});\n    /*displayCsv = displayCsv.map( group => group.map( word => [word, jsonDict[word]]))    ;\n    displayCsv = displayCsv.map( item => ({ group_name: item[0][0], words: item}));\n\n    // App.js\n    let wordGroups = displayCsv;\n    let cluster = 0;\n    let cleanedData = [];\n    console.log(wordGroups);\n\n    if (wordGroups){\n        for (let group of wordGroups) {\n            let words = group.words;\n            cleanedData.push({ value: '+', cluster: cluster});\n            for (let word of words){\n                cleanedData.push({ value: word, cluster: cluster})\n            }\n            cluster ++;\n        }\n    }\n\n    return cleanedData;*/\n}\n\nclass App extends React.Component {\n    constructor(props) {\n        super(props);\n        this.state = { data: [], cleaneddata: []};\n        \n        this.myFiles = [\"file1.csv\", \"file2.csv\", \"file3.csv\", \"file4.csv\", \"file5.csv\", \"file6.csv\", \"file7.csv\", \"file8.csv\", \"file9.csv\", \"gardenofproserpine.20200406093426.csv\", \"TestAnimation22.20200408082554.csv\", \"testdata25.20200413112616.csv\"];\n        this.myFile = 8;\n        this.othernodes = d3.range(10).map(d => Math.random());\n    }\n\n    getFile() {\n        this.myFile = (this.myFile + 1) % this.myFiles.length;\n        let serversite = \"http://lexikat-beta.com:5000/files/\"\n        let newFile = serversite + this.myFiles[this.myFile];\n        \n        fetch(newFile)\n                .then(res => res.text())\n                .then(data => {\n                    this.setState({ data: processCsvContent(data) });\n                });\n    }\n\n    updateState = (changedData) => {\n        this.setState({ cleanedData: changedData });\n    }\n\n    componentDidMount() {\n        this.getFile();\n    }\n\n    render() {\n        const { cleanedData } = this.state;\n        console.log(this.state.data);\n        return (\n            <div className=\"App\">\n                <button onClick={() => this.getFile()}> switch file </button>\n                {/*<div className={vizBoxStyle.container}>*/}\n                <div style={{margin: \"10px\"}}>\n                    <VizBox data={this.state.data} updateParentState={this.updateState} id=\"1\" />\n                    <VizBox data={this.state.data} updateParentState={this.updateState} id=\"2\" />\n                    <VizBox data={this.state.data} updateParentState={this.updateState} id=\"3\" />\n                </div>\n                {/*<div className={textStyle.container}>*/}\n                <div>\n                    <p>{JSON.stringify(cleanedData)}</p>\n                </div>\n            </div>\n        );\n    }\n}\n\nexport default App;\n","// This optional code is used to register a service worker.\n// register() is not called by default.\n\n// This lets the app load faster on subsequent visits in production, and gives\n// it offline capabilities. However, it also means that developers (and users)\n// will only see deployed updates on subsequent visits to a page, after all the\n// existing tabs open on the page have been closed, since previously cached\n// resources are updated in the background.\n\n// To learn more about the benefits of this model and instructions on how to\n// opt-in, read https://bit.ly/CRA-PWA\n\nconst isLocalhost = Boolean(\n  window.location.hostname === 'localhost' ||\n    // [::1] is the IPv6 localhost address.\n    window.location.hostname === '[::1]' ||\n    // 127.0.0.0/8 are considered localhost for IPv4.\n    window.location.hostname.match(\n      /^127(?:\\.(?:25[0-5]|2[0-4][0-9]|[01]?[0-9][0-9]?)){3}$/\n    )\n);\n\nexport function register(config) {\n  if (process.env.NODE_ENV === 'production' && 'serviceWorker' in navigator) {\n    // The URL constructor is available in all browsers that support SW.\n    const publicUrl = new URL(process.env.PUBLIC_URL, window.location.href);\n    if (publicUrl.origin !== window.location.origin) {\n      // Our service worker won't work if PUBLIC_URL is on a different origin\n      // from what our page is served on. This might happen if a CDN is used to\n      // serve assets; see https://github.com/facebook/create-react-app/issues/2374\n      return;\n    }\n\n    window.addEventListener('load', () => {\n      const swUrl = `${process.env.PUBLIC_URL}/service-worker.js`;\n\n      if (isLocalhost) {\n        // This is running on localhost. Let's check if a service worker still exists or not.\n        checkValidServiceWorker(swUrl, config);\n\n        // Add some additional logging to localhost, pointing developers to the\n        // service worker/PWA documentation.\n        navigator.serviceWorker.ready.then(() => {\n          console.log(\n            'This web app is being served cache-first by a service ' +\n              'worker. To learn more, visit https://bit.ly/CRA-PWA'\n          );\n        });\n      } else {\n        // Is not localhost. Just register service worker\n        registerValidSW(swUrl, config);\n      }\n    });\n  }\n}\n\nfunction registerValidSW(swUrl, config) {\n  navigator.serviceWorker\n    .register(swUrl)\n    .then(registration => {\n      registration.onupdatefound = () => {\n        const installingWorker = registration.installing;\n        if (installingWorker == null) {\n          return;\n        }\n        installingWorker.onstatechange = () => {\n          if (installingWorker.state === 'installed') {\n            if (navigator.serviceWorker.controller) {\n              // At this point, the updated precached content has been fetched,\n              // but the previous service worker will still serve the older\n              // content until all client tabs are closed.\n              console.log(\n                'New content is available and will be used when all ' +\n                  'tabs for this page are closed. See https://bit.ly/CRA-PWA.'\n              );\n\n              // Execute callback\n              if (config && config.onUpdate) {\n                config.onUpdate(registration);\n              }\n            } else {\n              // At this point, everything has been precached.\n              // It's the perfect time to display a\n              // \"Content is cached for offline use.\" message.\n              console.log('Content is cached for offline use.');\n\n              // Execute callback\n              if (config && config.onSuccess) {\n                config.onSuccess(registration);\n              }\n            }\n          }\n        };\n      };\n    })\n    .catch(error => {\n      console.error('Error during service worker registration:', error);\n    });\n}\n\nfunction checkValidServiceWorker(swUrl, config) {\n  // Check if the service worker can be found. If it can't reload the page.\n  fetch(swUrl, {\n    headers: { 'Service-Worker': 'script' },\n  })\n    .then(response => {\n      // Ensure service worker exists, and that we really are getting a JS file.\n      const contentType = response.headers.get('content-type');\n      if (\n        response.status === 404 ||\n        (contentType != null && contentType.indexOf('javascript') === -1)\n      ) {\n        // No service worker found. Probably a different app. Reload the page.\n        navigator.serviceWorker.ready.then(registration => {\n          registration.unregister().then(() => {\n            window.location.reload();\n          });\n        });\n      } else {\n        // Service worker found. Proceed as normal.\n        registerValidSW(swUrl, config);\n      }\n    })\n    .catch(() => {\n      console.log(\n        'No internet connection found. App is running in offline mode.'\n      );\n    });\n}\n\nexport function unregister() {\n  if ('serviceWorker' in navigator) {\n    navigator.serviceWorker.ready\n      .then(registration => {\n        registration.unregister();\n      })\n      .catch(error => {\n        console.error(error.message);\n      });\n  }\n}\n","import React from 'react';\nimport ReactDOM from 'react-dom';\nimport './index.css';\nimport App from './App';\nimport * as serviceWorker from './serviceWorker';\n\nReactDOM.render(\n  <React.StrictMode>\n    <App />\n  </React.StrictMode>,\n  document.getElementById('root')\n);\n\n// If you want your app to work offline and load faster, you can change\n// unregister() to register() below. Note this comes with some pitfalls.\n// Learn more about service workers: https://bit.ly/CRA-PWA\nserviceWorker.unregister();\n"],"sourceRoot":""}